var fs = require('fs');

// Is there a more elegant way of achieving this?
// mkdirp isn't found during the postinstall step because I guess we're in the wrong directory.
// But this js file doesn't really belong in app. Are we supposed to have a separate node_modules directory?
const mkdirp = require('../app/node_modules/mkdirp');

// When the documentation is generated by the markdown-html modul, some characters are altered
//   for the ids of the anchorpoints.
//   To replicate this when creating the navigation, this list contains all changing characters and their replacements.
//   The strings inside the list can be read the following way:
//
//    'character replaced by markdown-html'x'character the replaced one is changed to'
//
//    It can happen that multiple '-' are directly following each other. In this case the last three entrys
//    replaced these with one '-'.

var characters = ['#x', '?x-', '>x', '<x', ')x-', '(x-', ':x', ' x-', '.x', '/x-', "'x-", '`x', '"x', ',x', '!x-', '--x-', '--x-', '--x-', '--x-', '--x-', '--x-'];

function initializeNavigation() {
    fs.readFile('../app/resources/Documentation/documentationWindowPrefab.html', 'utf8', function (firstErr, html) {
        if (firstErr) {
            return console.log(firstErr);
        }
        var originalFile = html.split("<!--navigationentries-->");

        fs.readFile('../app/resources/Documentation/WritingWithInk.md', 'utf8', function (secErr, data) {
            if (secErr) {
                return console.log(secErr);
            }

            var output = originalFile[0];

            for (var line of data.split("\n")) {
                
                // checks whether the line does NOT contain a headline (indicated by the character '#'; the indexOf method will return -1 if the string does not contain the argument).
                // The second part checks if the first character of a line is a '#' (a markdown header).
                
                if (line.indexOf('#') === -1 || line.charAt(0) != '#') {
                    continue;
                }
                var headline;
                headline = line.split('#').join('').trim();

                //generating the ids for the documentation links
                id = headline.toLowerCase();
                console.log("before remove: " + id + "|")
                id = removeChineseCharacters(id);
                console.log("after remove: " + id + "|")
                var activeCharacter;
                for (var character of characters) {
                    activeCharacter = character.split('x');
                    id = id.split(activeCharacter[0]).join(activeCharacter[1]);
                }

                var headlineType;
                headlineType = 'h' + numberOfOccurrences(line, '#', false);
                output = output + ' ' + '<li><a id="#' + id + ' "onclick="openPath(this.id)" class="nav-' + headlineType + '">' + headline + '</a></li>\n';

            }
            output = output + originalFile[1];

            mkdirp.sync("../app/renderer/documentation/");
            
            fs.writeFile('../app/renderer/documentation/window.html', output, function (thirdErr) {
                if (thirdErr) {
                    return console.log(thirdErr);
                }

                console.log('Documentation was created');
            });
        });
    });

}
function numberOfOccurrences(searchIn, searchFor, allowOverlapping) {
    searchIn += "";
    searchFor += "";
    if (searchFor.length <= 0) return (searchIn.length + 1);

    var n = 0,
        pos = 0,
        step = allowOverlapping ? 1 : searchFor.length;

    while (true) {
        pos = searchIn.indexOf(searchFor, pos);
        if (pos >= 0) {
            ++n;
            pos += step;
        } else break;
    }
    return n;
}

// 生成文档时，古早的 markdown-html 已经无法处理中文，所以我们生成 id 时，把中文去除掉，才能使得 id 匹配
function removeChineseCharacters(str) {
    return str.replace(/[\u4e00-\u9fa5，。！？；：“”‘’]/g, ''); // 匹配中文字符和常见中文标点符号   
}

initializeNavigation();